# Task switching settings
TASKSWITCH_PER_SEC = 100

# Maximum tasks to be run at any one time
TASK_MAX = 400

# Turn on kernel debugging output
# This sets the highest level of debugging to display. Choices are:
# KP_TRACE
# KP_DEBUG
# KP_NORMAL
# KP_WARNING
# KP_ERROR
KERNEL_LOG_LEVEL = KP_NORMAL

# The below flags allow setting finer-grained control over the debug output.
#
# If these are set, then locking and unlocking will be reported on KP_DEBUG
# Note, we don't bother with spinlocks, it's simply way to much, and the
# majority of usages of spinlocks won't have problems simply because their
# critical section is short. If you really want to log spinlocks, set
# KERNEL_LOG_SPINLOCK to y
KERNEL_LOG_LOCKING = n
KERNEL_LOG_SPINLOCK = n
KERNEL_LOG_EXT2 = n
KERNEL_LOG_INODE_LOCK = n
KERNEL_LOG_ELF = y
KERNEL_LOG_VFS = n
KERNEL_LOG_SLAB = n

KERNEL_LOG_NET = y
KERNEL_LOG_IP = y
KERNEL_LOG_ICMP = y
KERNEL_LOG_UDP = y
KERNEL_LOG_TCP = y

KERNEL_TESTS = y

# If set, then the source location of the kp() is recorded in the log.
KERNEL_LOG_SRC_LINE = n

# Max number of outputs that can be sent the kernel log directly from kernel
# space.
KERNEL_LOG_MAX_OUTPUTS = 2

# Locate the kernel at the 3rd GB
KERNEL_BASE = 0xC0000000

# Initial ammount of memory that the kernel needs - 
# 16 MB's. Note that if this is too small, the kernel will fail on boot-up.
KERNEL_SIZE = 0x01000000

# Location for the bootloader to load the kernel at
KERNEL_EXTMEM = 0x00100000

# Location that a programs code will be loaded at
KERNEL_PROGRAM_LINK = 0x08048000

# Measured in pages - 2048 - 8MB
# Loaded via demand paging, so not every process needs the full amount mapped.
KERNEL_PROGRAM_STACK = 2048

# Amount of memory to take away from the top of the Kernel's memory to be used
# for kmap.
KERNEL_KMAP_START = 0xF0000000
KERNEL_KMAP_SIZE = 0x10000000

KERNEL_ARG_PAGES = 4

# Measured in bytes
KEYBOARD_BUFSZ = 256
COM_BUFSZ = 1024

# Necessary if you want proper stack-traces on panics or etc.
FRAME_POINTER = y

# This flag enables or disables block valid/dirty checking, via a CRC over the
# data. Essencially, this guards against forgetting to set block->dirty after
# modifying block->data, by checking block->data with a CRC check if
# block->dirty isn't set.
BLOCK_CHANGE_CRC_CHECK = y

# Similar but more intrusive then the BLOCK_CHANGE_CRC_CHECK. This checks the
# inode dirty flag for consistency. Unlike the block data with the CRC, the
# inode data is verified by simply reading the inode block from the disk and
# checking the information.
INODE_CHANGE_CHECK = y

# Max number of pages that can be used by a pipe for holding data
#
# Note: Data written to pipes is never discarded. If a pipe lacks enough space
# to store some data, then the call to write() will hang until space is made
# availiable from another program calling read() and removing some of the data
# from the pipe. Larger pipe's will cause less hanging due to the pipe being
# out of space. This space is allocated on-demand, but also held for the life
# of the pipe once allocated.
PIPE_MAX_PAGES = 10

# Filesystem to mount on boot
ROOT_MAJOR = BLOCK_DEV_IDE_MASTER
ROOT_MINOR = 1
ROOT_FSTYPE = "ext2"

# Max number of symlinks to follow in one name
LINK_MAX = 10

#### Below is hardware support options ####

# Determines if support for PC COM serial port should be compiled
PC_COM_SERIAL_DRIVER = y

# Compile support for TTY
TTY_DRIVER = y

# Compile support for 'console' (keyword + screen)
CONSOLE_DRIVER = y

# Console support for IDE
IDE_DRIVER = y
# DMA support is bugged and doesn't work on VirtualBox
IDE_DMA_SUPPORT = n

PCI_SUPPORT = y

NET_SUPPORT = y

NET_RTL8139_DRIVER = y
NET_E1000_DRIVER = y
NET_LOOPBACK_DRIVER = y

FS_EXT2_DRIVER = y
FS_PROCFS_DRIVER = y

